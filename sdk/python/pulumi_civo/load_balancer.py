# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from . import _utilities, _tables
from . import outputs
from ._inputs import *

__all__ = ['LoadBalancer']


class LoadBalancer(pulumi.CustomResource):
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerBackendArgs']]]]] = None,
                 fail_timeout: Optional[pulumi.Input[int]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ignore_invalid_backend_tls: Optional[pulumi.Input[bool]] = None,
                 max_conns: Optional[pulumi.Input[int]] = None,
                 max_request_size: Optional[pulumi.Input[int]] = None,
                 policy: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 tls_certificate: Optional[pulumi.Input[str]] = None,
                 tls_key: Optional[pulumi.Input[str]] = None,
                 __props__=None,
                 __name__=None,
                 __opts__=None):
        """
        Create a LoadBalancer resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerBackendArgs']]]] backends: a list of backend instances, each containing an instance_id, protocol (http or https) and port
        :param pulumi.Input[int] fail_timeout: how long to wait in seconds before determining a backend has failed, defaults to 30
        :param pulumi.Input[str] health_check_path: what URL should be used on the backends to determine if it's OK (2xx/3xx status), defaults to /
        :param pulumi.Input[str] hostname: the hostname to receive traffic for, e.g. www.example.com (optional: sets hostname to loadbalancer-uuid.civo.com if
               blank)
        :param pulumi.Input[bool] ignore_invalid_backend_tls: should self-signed/invalid certificates be ignored from the backend servers, defaults to true
        :param pulumi.Input[int] max_conns: how many concurrent connections can each backend handle, defaults to 10
        :param pulumi.Input[int] max_request_size: the size in megabytes of the maximum request content that will be accepted, defaults to 20
        :param pulumi.Input[str] policy: one of: least_conn (sends new requests to the least busy server), random (sends new requests to a random backend),
               round_robin (sends new requests to the next backend in order), ip_hash (sends requests from a given IP address to the
               same backend), default is random
        :param pulumi.Input[int] port: you can listen on any port, the default is 80 to match the default protocol of http,if not you must specify it here
               (commonly 80 for HTTP or 443 for HTTPS)
        :param pulumi.Input[str] protocol: either http or https. If you specify https then you must also provide the next two fields, the default is http
        :param pulumi.Input[str] tls_certificate: if your protocol is https then you should send the TLS certificate in Base64-encoded PEM format
        :param pulumi.Input[str] tls_key: if your protocol is https then you should send the TLS private key in Base64-encoded PEM format
        """
        if __name__ is not None:
            warnings.warn("explicit use of __name__ is deprecated", DeprecationWarning)
            resource_name = __name__
        if __opts__ is not None:
            warnings.warn("explicit use of __opts__ is deprecated, use 'opts' instead", DeprecationWarning)
            opts = __opts__
        if opts is None:
            opts = pulumi.ResourceOptions()
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.version is None:
            opts.version = _utilities.get_version()
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = dict()

            if backends is None and not opts.urn:
                raise TypeError("Missing required property 'backends'")
            __props__['backends'] = backends
            if fail_timeout is None and not opts.urn:
                raise TypeError("Missing required property 'fail_timeout'")
            __props__['fail_timeout'] = fail_timeout
            __props__['health_check_path'] = health_check_path
            if hostname is None and not opts.urn:
                raise TypeError("Missing required property 'hostname'")
            __props__['hostname'] = hostname
            __props__['ignore_invalid_backend_tls'] = ignore_invalid_backend_tls
            if max_conns is None and not opts.urn:
                raise TypeError("Missing required property 'max_conns'")
            __props__['max_conns'] = max_conns
            if max_request_size is None and not opts.urn:
                raise TypeError("Missing required property 'max_request_size'")
            __props__['max_request_size'] = max_request_size
            if policy is None and not opts.urn:
                raise TypeError("Missing required property 'policy'")
            __props__['policy'] = policy
            if port is None and not opts.urn:
                raise TypeError("Missing required property 'port'")
            __props__['port'] = port
            if protocol is None and not opts.urn:
                raise TypeError("Missing required property 'protocol'")
            __props__['protocol'] = protocol
            __props__['tls_certificate'] = tls_certificate
            __props__['tls_key'] = tls_key
        super(LoadBalancer, __self__).__init__(
            'civo:index/loadBalancer:LoadBalancer',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            backends: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerBackendArgs']]]]] = None,
            fail_timeout: Optional[pulumi.Input[int]] = None,
            health_check_path: Optional[pulumi.Input[str]] = None,
            hostname: Optional[pulumi.Input[str]] = None,
            ignore_invalid_backend_tls: Optional[pulumi.Input[bool]] = None,
            max_conns: Optional[pulumi.Input[int]] = None,
            max_request_size: Optional[pulumi.Input[int]] = None,
            policy: Optional[pulumi.Input[str]] = None,
            port: Optional[pulumi.Input[int]] = None,
            protocol: Optional[pulumi.Input[str]] = None,
            tls_certificate: Optional[pulumi.Input[str]] = None,
            tls_key: Optional[pulumi.Input[str]] = None) -> 'LoadBalancer':
        """
        Get an existing LoadBalancer resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerBackendArgs']]]] backends: a list of backend instances, each containing an instance_id, protocol (http or https) and port
        :param pulumi.Input[int] fail_timeout: how long to wait in seconds before determining a backend has failed, defaults to 30
        :param pulumi.Input[str] health_check_path: what URL should be used on the backends to determine if it's OK (2xx/3xx status), defaults to /
        :param pulumi.Input[str] hostname: the hostname to receive traffic for, e.g. www.example.com (optional: sets hostname to loadbalancer-uuid.civo.com if
               blank)
        :param pulumi.Input[bool] ignore_invalid_backend_tls: should self-signed/invalid certificates be ignored from the backend servers, defaults to true
        :param pulumi.Input[int] max_conns: how many concurrent connections can each backend handle, defaults to 10
        :param pulumi.Input[int] max_request_size: the size in megabytes of the maximum request content that will be accepted, defaults to 20
        :param pulumi.Input[str] policy: one of: least_conn (sends new requests to the least busy server), random (sends new requests to a random backend),
               round_robin (sends new requests to the next backend in order), ip_hash (sends requests from a given IP address to the
               same backend), default is random
        :param pulumi.Input[int] port: you can listen on any port, the default is 80 to match the default protocol of http,if not you must specify it here
               (commonly 80 for HTTP or 443 for HTTPS)
        :param pulumi.Input[str] protocol: either http or https. If you specify https then you must also provide the next two fields, the default is http
        :param pulumi.Input[str] tls_certificate: if your protocol is https then you should send the TLS certificate in Base64-encoded PEM format
        :param pulumi.Input[str] tls_key: if your protocol is https then you should send the TLS private key in Base64-encoded PEM format
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = dict()

        __props__["backends"] = backends
        __props__["fail_timeout"] = fail_timeout
        __props__["health_check_path"] = health_check_path
        __props__["hostname"] = hostname
        __props__["ignore_invalid_backend_tls"] = ignore_invalid_backend_tls
        __props__["max_conns"] = max_conns
        __props__["max_request_size"] = max_request_size
        __props__["policy"] = policy
        __props__["port"] = port
        __props__["protocol"] = protocol
        __props__["tls_certificate"] = tls_certificate
        __props__["tls_key"] = tls_key
        return LoadBalancer(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def backends(self) -> pulumi.Output[Sequence['outputs.LoadBalancerBackend']]:
        """
        a list of backend instances, each containing an instance_id, protocol (http or https) and port
        """
        return pulumi.get(self, "backends")

    @property
    @pulumi.getter(name="failTimeout")
    def fail_timeout(self) -> pulumi.Output[int]:
        """
        how long to wait in seconds before determining a backend has failed, defaults to 30
        """
        return pulumi.get(self, "fail_timeout")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> pulumi.Output[Optional[str]]:
        """
        what URL should be used on the backends to determine if it's OK (2xx/3xx status), defaults to /
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Output[str]:
        """
        the hostname to receive traffic for, e.g. www.example.com (optional: sets hostname to loadbalancer-uuid.civo.com if
        blank)
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ignoreInvalidBackendTls")
    def ignore_invalid_backend_tls(self) -> pulumi.Output[Optional[bool]]:
        """
        should self-signed/invalid certificates be ignored from the backend servers, defaults to true
        """
        return pulumi.get(self, "ignore_invalid_backend_tls")

    @property
    @pulumi.getter(name="maxConns")
    def max_conns(self) -> pulumi.Output[int]:
        """
        how many concurrent connections can each backend handle, defaults to 10
        """
        return pulumi.get(self, "max_conns")

    @property
    @pulumi.getter(name="maxRequestSize")
    def max_request_size(self) -> pulumi.Output[int]:
        """
        the size in megabytes of the maximum request content that will be accepted, defaults to 20
        """
        return pulumi.get(self, "max_request_size")

    @property
    @pulumi.getter
    def policy(self) -> pulumi.Output[str]:
        """
        one of: least_conn (sends new requests to the least busy server), random (sends new requests to a random backend),
        round_robin (sends new requests to the next backend in order), ip_hash (sends requests from a given IP address to the
        same backend), default is random
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def port(self) -> pulumi.Output[int]:
        """
        you can listen on any port, the default is 80 to match the default protocol of http,if not you must specify it here
        (commonly 80 for HTTP or 443 for HTTPS)
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Output[str]:
        """
        either http or https. If you specify https then you must also provide the next two fields, the default is http
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="tlsCertificate")
    def tls_certificate(self) -> pulumi.Output[Optional[str]]:
        """
        if your protocol is https then you should send the TLS certificate in Base64-encoded PEM format
        """
        return pulumi.get(self, "tls_certificate")

    @property
    @pulumi.getter(name="tlsKey")
    def tls_key(self) -> pulumi.Output[Optional[str]]:
        """
        if your protocol is https then you should send the TLS private key in Base64-encoded PEM format
        """
        return pulumi.get(self, "tls_key")

    def translate_output_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop

    def translate_input_property(self, prop):
        return _tables.SNAKE_TO_CAMEL_CASE_TABLE.get(prop) or prop

