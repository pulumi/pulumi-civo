# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'FirewallEgressRule',
    'FirewallIngressRule',
    'KubernetesClusterInstalledApplication',
    'KubernetesClusterPools',
    'KubernetesNodePoolTaint',
    'GetDatabaseVersionFilterResult',
    'GetDatabaseVersionSortResult',
    'GetDatabaseVersionVersionResult',
    'GetDiskImageDiskimageResult',
    'GetDiskImageFilterResult',
    'GetDiskImageSortResult',
    'GetInstancesFilterResult',
    'GetInstancesInstanceResult',
    'GetInstancesSortResult',
    'GetKubernetesClusterInstalledApplicationResult',
    'GetKubernetesClusterPoolResult',
    'GetKubernetesVersionFilterResult',
    'GetKubernetesVersionSortResult',
    'GetKubernetesVersionVersionResult',
    'GetLoadBalancerBackendResult',
    'GetRegionFilterResult',
    'GetRegionRegionResult',
    'GetRegionSortResult',
    'GetSizeFilterResult',
    'GetSizeSizeResult',
    'GetSizeSortResult',
]

@pulumi.output_type
class FirewallEgressRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallEgressRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallEgressRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallEgressRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 cidrs: Sequence[str],
                 id: Optional[str] = None,
                 label: Optional[str] = None,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str action: The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
        :param Sequence[str] cidrs: The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
        :param str label: A string that will be the displayed name/reference for this rule
        :param str port_range: The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
        :param str protocol: The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
        """
        FirewallEgressRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            cidrs=cidrs,
            id=id,
            label=label,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             cidrs: Optional[Sequence[str]] = None,
             id: Optional[str] = None,
             label: Optional[str] = None,
             port_range: Optional[str] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if cidrs is None:
            raise TypeError("Missing 'cidrs' argument")
        if port_range is None and 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        _setter("cidrs", cidrs)
        if id is not None:
            _setter("id", id)
        if label is not None:
            _setter("label", label)
        if port_range is not None:
            _setter("port_range", port_range)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def cidrs(self) -> Sequence[str]:
        """
        The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
        """
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A string that will be the displayed name/reference for this rule
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class FirewallIngressRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallIngressRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallIngressRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallIngressRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 cidrs: Sequence[str],
                 id: Optional[str] = None,
                 label: Optional[str] = None,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str action: The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
        :param Sequence[str] cidrs: The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
        :param str label: A string that will be the displayed name/reference for this rule
        :param str port_range: The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
        :param str protocol: The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
        """
        FirewallIngressRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            cidrs=cidrs,
            id=id,
            label=label,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             cidrs: Optional[Sequence[str]] = None,
             id: Optional[str] = None,
             label: Optional[str] = None,
             port_range: Optional[str] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if cidrs is None:
            raise TypeError("Missing 'cidrs' argument")
        if port_range is None and 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        _setter("cidrs", cidrs)
        if id is not None:
            _setter("id", id)
        if label is not None:
            _setter("label", label)
        if port_range is not None:
            _setter("port_range", port_range)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def cidrs(self) -> Sequence[str]:
        """
        The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
        """
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A string that will be the displayed name/reference for this rule
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class KubernetesClusterInstalledApplication(dict):
    def __init__(__self__, *,
                 application: Optional[str] = None,
                 category: Optional[str] = None,
                 installed: Optional[bool] = None,
                 version: Optional[str] = None):
        KubernetesClusterInstalledApplication._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application=application,
            category=category,
            installed=installed,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application: Optional[str] = None,
             category: Optional[str] = None,
             installed: Optional[bool] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if application is not None:
            _setter("application", application)
        if category is not None:
            _setter("category", category)
        if installed is not None:
            _setter("installed", installed)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def application(self) -> Optional[str]:
        return pulumi.get(self, "application")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def installed(self) -> Optional[bool]:
        return pulumi.get(self, "installed")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class KubernetesClusterPools(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeCount":
            suggest = "node_count"
        elif key == "instanceNames":
            suggest = "instance_names"
        elif key == "publicIpNodePool":
            suggest = "public_ip_node_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterPools. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterPools.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterPools.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_count: int,
                 size: str,
                 instance_names: Optional[Sequence[str]] = None,
                 label: Optional[str] = None,
                 public_ip_node_pool: Optional[bool] = None):
        """
        :param int node_count: Number of nodes in the nodepool
        :param str size: Size of the nodes in the nodepool
        :param Sequence[str] instance_names: Instance names in the nodepool
        :param str label: Node pool label, if you don't provide one, we will generate one for you
        :param bool public_ip_node_pool: Node pool belongs to the public ip node pool
        """
        KubernetesClusterPools._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            node_count=node_count,
            size=size,
            instance_names=instance_names,
            label=label,
            public_ip_node_pool=public_ip_node_pool,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             node_count: Optional[int] = None,
             size: Optional[str] = None,
             instance_names: Optional[Sequence[str]] = None,
             label: Optional[str] = None,
             public_ip_node_pool: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if node_count is None and 'nodeCount' in kwargs:
            node_count = kwargs['nodeCount']
        if node_count is None:
            raise TypeError("Missing 'node_count' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if instance_names is None and 'instanceNames' in kwargs:
            instance_names = kwargs['instanceNames']
        if public_ip_node_pool is None and 'publicIpNodePool' in kwargs:
            public_ip_node_pool = kwargs['publicIpNodePool']

        _setter("node_count", node_count)
        _setter("size", size)
        if instance_names is not None:
            _setter("instance_names", instance_names)
        if label is not None:
            _setter("label", label)
        if public_ip_node_pool is not None:
            _setter("public_ip_node_pool", public_ip_node_pool)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        Number of nodes in the nodepool
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Size of the nodes in the nodepool
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="instanceNames")
    def instance_names(self) -> Optional[Sequence[str]]:
        """
        Instance names in the nodepool
        """
        return pulumi.get(self, "instance_names")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Node pool label, if you don't provide one, we will generate one for you
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="publicIpNodePool")
    def public_ip_node_pool(self) -> Optional[bool]:
        """
        Node pool belongs to the public ip node pool
        """
        return pulumi.get(self, "public_ip_node_pool")


@pulumi.output_type
class KubernetesNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        KubernetesNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if effect is None:
            raise TypeError("Missing 'effect' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("effect", effect)
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseVersionFilterResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter versions by this key. This may be one of `default`, `engine`, `version`.
        :param Sequence[str] values: Only retrieves `versions` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        GetDatabaseVersionFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            values=values,
            all=all,
            match_by=match_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             all: Optional[bool] = None,
             match_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")
        if match_by is None and 'matchBy' in kwargs:
            match_by = kwargs['matchBy']

        _setter("key", key)
        _setter("values", values)
        if all is not None:
            _setter("all", all)
        if match_by is not None:
            _setter("match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter versions by this key. This may be one of `default`, `engine`, `version`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `versions` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetDatabaseVersionSortResult(dict):
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort versions by this key. This may be one of `default`, `engine`, `version`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        GetDatabaseVersionSortResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            direction=direction,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             direction: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("key", key)
        if direction is not None:
            _setter("direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort versions by this key. This may be one of `default`, `engine`, `version`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetDatabaseVersionVersionResult(dict):
    def __init__(__self__, *,
                 default: bool,
                 engine: str,
                 version: str):
        GetDatabaseVersionVersionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default=default,
            engine=engine,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default: Optional[bool] = None,
             engine: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default is None:
            raise TypeError("Missing 'default' argument")
        if engine is None:
            raise TypeError("Missing 'engine' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("default", default)
        _setter("engine", engine)
        _setter("version", version)

    @property
    @pulumi.getter
    def default(self) -> bool:
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def engine(self) -> str:
        return pulumi.get(self, "engine")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDiskImageDiskimageResult(dict):
    def __init__(__self__, *,
                 id: str,
                 label: str,
                 name: str,
                 version: str):
        GetDiskImageDiskimageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            label=label,
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             label: Optional[str] = None,
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if label is None:
            raise TypeError("Missing 'label' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("id", id)
        _setter("label", label)
        _setter("name", name)
        _setter("version", version)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDiskImageFilterResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter diskimages by this key. This may be one of `id`, `label`, `name`, `version`.
        :param Sequence[str] values: Only retrieves `diskimages` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        GetDiskImageFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            values=values,
            all=all,
            match_by=match_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             all: Optional[bool] = None,
             match_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")
        if match_by is None and 'matchBy' in kwargs:
            match_by = kwargs['matchBy']

        _setter("key", key)
        _setter("values", values)
        if all is not None:
            _setter("all", all)
        if match_by is not None:
            _setter("match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter diskimages by this key. This may be one of `id`, `label`, `name`, `version`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `diskimages` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetDiskImageSortResult(dict):
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort diskimages by this key. This may be one of `id`, `label`, `name`, `version`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        GetDiskImageSortResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            direction=direction,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             direction: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("key", key)
        if direction is not None:
            _setter("direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort diskimages by this key. This may be one of `id`, `label`, `name`, `version`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetInstancesFilterResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter instances by this key. This may be one of `cpu_cores`, `created_at`, `disk_gb`, `firewall_id`, `hostname`, `id`, `initial_password`, `initial_user`, `network_id`, `notes`, `private_ip`, `pseudo_ip`, `public_ip`, `ram_mb`, `region`, `reverse_dns`, `script`, `size`, `sshkey_id`, `status`, `tags`, `template`.
        :param Sequence[str] values: Only retrieves `instances` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        GetInstancesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            values=values,
            all=all,
            match_by=match_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             all: Optional[bool] = None,
             match_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")
        if match_by is None and 'matchBy' in kwargs:
            match_by = kwargs['matchBy']

        _setter("key", key)
        _setter("values", values)
        if all is not None:
            _setter("all", all)
        if match_by is not None:
            _setter("match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter instances by this key. This may be one of `cpu_cores`, `created_at`, `disk_gb`, `firewall_id`, `hostname`, `id`, `initial_password`, `initial_user`, `network_id`, `notes`, `private_ip`, `pseudo_ip`, `public_ip`, `ram_mb`, `region`, `reverse_dns`, `script`, `size`, `sshkey_id`, `status`, `tags`, `template`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `instances` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 cpu_cores: int,
                 created_at: str,
                 disk_gb: int,
                 firewall_id: str,
                 hostname: str,
                 id: str,
                 initial_password: str,
                 initial_user: str,
                 network_id: str,
                 notes: str,
                 private_ip: str,
                 pseudo_ip: str,
                 public_ip: str,
                 ram_mb: int,
                 region: str,
                 reverse_dns: str,
                 script: str,
                 size: str,
                 sshkey_id: str,
                 status: str,
                 tags: Sequence[str],
                 template: str):
        GetInstancesInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_cores=cpu_cores,
            created_at=created_at,
            disk_gb=disk_gb,
            firewall_id=firewall_id,
            hostname=hostname,
            id=id,
            initial_password=initial_password,
            initial_user=initial_user,
            network_id=network_id,
            notes=notes,
            private_ip=private_ip,
            pseudo_ip=pseudo_ip,
            public_ip=public_ip,
            ram_mb=ram_mb,
            region=region,
            reverse_dns=reverse_dns,
            script=script,
            size=size,
            sshkey_id=sshkey_id,
            status=status,
            tags=tags,
            template=template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_cores: Optional[int] = None,
             created_at: Optional[str] = None,
             disk_gb: Optional[int] = None,
             firewall_id: Optional[str] = None,
             hostname: Optional[str] = None,
             id: Optional[str] = None,
             initial_password: Optional[str] = None,
             initial_user: Optional[str] = None,
             network_id: Optional[str] = None,
             notes: Optional[str] = None,
             private_ip: Optional[str] = None,
             pseudo_ip: Optional[str] = None,
             public_ip: Optional[str] = None,
             ram_mb: Optional[int] = None,
             region: Optional[str] = None,
             reverse_dns: Optional[str] = None,
             script: Optional[str] = None,
             size: Optional[str] = None,
             sshkey_id: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Sequence[str]] = None,
             template: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_cores is None and 'cpuCores' in kwargs:
            cpu_cores = kwargs['cpuCores']
        if cpu_cores is None:
            raise TypeError("Missing 'cpu_cores' argument")
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_at is None:
            raise TypeError("Missing 'created_at' argument")
        if disk_gb is None and 'diskGb' in kwargs:
            disk_gb = kwargs['diskGb']
        if disk_gb is None:
            raise TypeError("Missing 'disk_gb' argument")
        if firewall_id is None and 'firewallId' in kwargs:
            firewall_id = kwargs['firewallId']
        if firewall_id is None:
            raise TypeError("Missing 'firewall_id' argument")
        if hostname is None:
            raise TypeError("Missing 'hostname' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if initial_password is None and 'initialPassword' in kwargs:
            initial_password = kwargs['initialPassword']
        if initial_password is None:
            raise TypeError("Missing 'initial_password' argument")
        if initial_user is None and 'initialUser' in kwargs:
            initial_user = kwargs['initialUser']
        if initial_user is None:
            raise TypeError("Missing 'initial_user' argument")
        if network_id is None and 'networkId' in kwargs:
            network_id = kwargs['networkId']
        if network_id is None:
            raise TypeError("Missing 'network_id' argument")
        if notes is None:
            raise TypeError("Missing 'notes' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")
        if pseudo_ip is None and 'pseudoIp' in kwargs:
            pseudo_ip = kwargs['pseudoIp']
        if pseudo_ip is None:
            raise TypeError("Missing 'pseudo_ip' argument")
        if public_ip is None and 'publicIp' in kwargs:
            public_ip = kwargs['publicIp']
        if public_ip is None:
            raise TypeError("Missing 'public_ip' argument")
        if ram_mb is None and 'ramMb' in kwargs:
            ram_mb = kwargs['ramMb']
        if ram_mb is None:
            raise TypeError("Missing 'ram_mb' argument")
        if region is None:
            raise TypeError("Missing 'region' argument")
        if reverse_dns is None and 'reverseDns' in kwargs:
            reverse_dns = kwargs['reverseDns']
        if reverse_dns is None:
            raise TypeError("Missing 'reverse_dns' argument")
        if script is None:
            raise TypeError("Missing 'script' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if sshkey_id is None and 'sshkeyId' in kwargs:
            sshkey_id = kwargs['sshkeyId']
        if sshkey_id is None:
            raise TypeError("Missing 'sshkey_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if template is None:
            raise TypeError("Missing 'template' argument")

        _setter("cpu_cores", cpu_cores)
        _setter("created_at", created_at)
        _setter("disk_gb", disk_gb)
        _setter("firewall_id", firewall_id)
        _setter("hostname", hostname)
        _setter("id", id)
        _setter("initial_password", initial_password)
        _setter("initial_user", initial_user)
        _setter("network_id", network_id)
        _setter("notes", notes)
        _setter("private_ip", private_ip)
        _setter("pseudo_ip", pseudo_ip)
        _setter("public_ip", public_ip)
        _setter("ram_mb", ram_mb)
        _setter("region", region)
        _setter("reverse_dns", reverse_dns)
        _setter("script", script)
        _setter("size", size)
        _setter("sshkey_id", sshkey_id)
        _setter("status", status)
        _setter("tags", tags)
        _setter("template", template)

    @property
    @pulumi.getter(name="cpuCores")
    def cpu_cores(self) -> int:
        return pulumi.get(self, "cpu_cores")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="diskGb")
    def disk_gb(self) -> int:
        return pulumi.get(self, "disk_gb")

    @property
    @pulumi.getter(name="firewallId")
    def firewall_id(self) -> str:
        return pulumi.get(self, "firewall_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="initialPassword")
    def initial_password(self) -> str:
        return pulumi.get(self, "initial_password")

    @property
    @pulumi.getter(name="initialUser")
    def initial_user(self) -> str:
        return pulumi.get(self, "initial_user")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter
    def notes(self) -> str:
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="pseudoIp")
    def pseudo_ip(self) -> str:
        return pulumi.get(self, "pseudo_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="ramMb")
    def ram_mb(self) -> int:
        return pulumi.get(self, "ram_mb")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="reverseDns")
    def reverse_dns(self) -> str:
        return pulumi.get(self, "reverse_dns")

    @property
    @pulumi.getter
    def script(self) -> str:
        return pulumi.get(self, "script")

    @property
    @pulumi.getter
    def size(self) -> str:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sshkeyId")
    def sshkey_id(self) -> str:
        return pulumi.get(self, "sshkey_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def template(self) -> str:
        return pulumi.get(self, "template")


@pulumi.output_type
class GetInstancesSortResult(dict):
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort instances by this key. This may be one of `cpu_cores`, `created_at`, `disk_gb`, `firewall_id`, `hostname`, `id`, `initial_password`, `initial_user`, `network_id`, `notes`, `private_ip`, `pseudo_ip`, `public_ip`, `ram_mb`, `region`, `reverse_dns`, `script`, `size`, `sshkey_id`, `status`, `template`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        GetInstancesSortResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            direction=direction,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             direction: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("key", key)
        if direction is not None:
            _setter("direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort instances by this key. This may be one of `cpu_cores`, `created_at`, `disk_gb`, `firewall_id`, `hostname`, `id`, `initial_password`, `initial_user`, `network_id`, `notes`, `private_ip`, `pseudo_ip`, `public_ip`, `ram_mb`, `region`, `reverse_dns`, `script`, `size`, `sshkey_id`, `status`, `template`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetKubernetesClusterInstalledApplicationResult(dict):
    def __init__(__self__, *,
                 application: str,
                 category: str,
                 installed: bool,
                 version: str):
        GetKubernetesClusterInstalledApplicationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application=application,
            category=category,
            installed=installed,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application: Optional[str] = None,
             category: Optional[str] = None,
             installed: Optional[bool] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application is None:
            raise TypeError("Missing 'application' argument")
        if category is None:
            raise TypeError("Missing 'category' argument")
        if installed is None:
            raise TypeError("Missing 'installed' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("application", application)
        _setter("category", category)
        _setter("installed", installed)
        _setter("version", version)

    @property
    @pulumi.getter
    def application(self) -> str:
        return pulumi.get(self, "application")

    @property
    @pulumi.getter
    def category(self) -> str:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def installed(self) -> bool:
        return pulumi.get(self, "installed")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetKubernetesClusterPoolResult(dict):
    def __init__(__self__, *,
                 instance_names: Sequence[str],
                 label: str,
                 node_count: int,
                 public_ip_node_pool: bool,
                 size: str):
        GetKubernetesClusterPoolResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_names=instance_names,
            label=label,
            node_count=node_count,
            public_ip_node_pool=public_ip_node_pool,
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_names: Optional[Sequence[str]] = None,
             label: Optional[str] = None,
             node_count: Optional[int] = None,
             public_ip_node_pool: Optional[bool] = None,
             size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_names is None and 'instanceNames' in kwargs:
            instance_names = kwargs['instanceNames']
        if instance_names is None:
            raise TypeError("Missing 'instance_names' argument")
        if label is None:
            raise TypeError("Missing 'label' argument")
        if node_count is None and 'nodeCount' in kwargs:
            node_count = kwargs['nodeCount']
        if node_count is None:
            raise TypeError("Missing 'node_count' argument")
        if public_ip_node_pool is None and 'publicIpNodePool' in kwargs:
            public_ip_node_pool = kwargs['publicIpNodePool']
        if public_ip_node_pool is None:
            raise TypeError("Missing 'public_ip_node_pool' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")

        _setter("instance_names", instance_names)
        _setter("label", label)
        _setter("node_count", node_count)
        _setter("public_ip_node_pool", public_ip_node_pool)
        _setter("size", size)

    @property
    @pulumi.getter(name="instanceNames")
    def instance_names(self) -> Sequence[str]:
        return pulumi.get(self, "instance_names")

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="publicIpNodePool")
    def public_ip_node_pool(self) -> bool:
        return pulumi.get(self, "public_ip_node_pool")

    @property
    @pulumi.getter
    def size(self) -> str:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetKubernetesVersionFilterResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter versions by this key. This may be one of `default`, `label`, `type`, `version`.
        :param Sequence[str] values: Only retrieves `versions` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        GetKubernetesVersionFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            values=values,
            all=all,
            match_by=match_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             all: Optional[bool] = None,
             match_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")
        if match_by is None and 'matchBy' in kwargs:
            match_by = kwargs['matchBy']

        _setter("key", key)
        _setter("values", values)
        if all is not None:
            _setter("all", all)
        if match_by is not None:
            _setter("match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter versions by this key. This may be one of `default`, `label`, `type`, `version`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `versions` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetKubernetesVersionSortResult(dict):
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort versions by this key. This may be one of `default`, `label`, `type`, `version`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        GetKubernetesVersionSortResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            direction=direction,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             direction: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("key", key)
        if direction is not None:
            _setter("direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort versions by this key. This may be one of `default`, `label`, `type`, `version`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetKubernetesVersionVersionResult(dict):
    def __init__(__self__, *,
                 default: bool,
                 label: str,
                 type: str,
                 version: str):
        GetKubernetesVersionVersionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default=default,
            label=label,
            type=type,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default: Optional[bool] = None,
             label: Optional[str] = None,
             type: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default is None:
            raise TypeError("Missing 'default' argument")
        if label is None:
            raise TypeError("Missing 'label' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("default", default)
        _setter("label", label)
        _setter("type", type)
        _setter("version", version)

    @property
    @pulumi.getter
    def default(self) -> bool:
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetLoadBalancerBackendResult(dict):
    def __init__(__self__, *,
                 health_check_port: int,
                 ip: str,
                 protocol: str,
                 source_port: int,
                 target_port: int):
        GetLoadBalancerBackendResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            health_check_port=health_check_port,
            ip=ip,
            protocol=protocol,
            source_port=source_port,
            target_port=target_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             health_check_port: Optional[int] = None,
             ip: Optional[str] = None,
             protocol: Optional[str] = None,
             source_port: Optional[int] = None,
             target_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if health_check_port is None and 'healthCheckPort' in kwargs:
            health_check_port = kwargs['healthCheckPort']
        if health_check_port is None:
            raise TypeError("Missing 'health_check_port' argument")
        if ip is None:
            raise TypeError("Missing 'ip' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if source_port is None and 'sourcePort' in kwargs:
            source_port = kwargs['sourcePort']
        if source_port is None:
            raise TypeError("Missing 'source_port' argument")
        if target_port is None and 'targetPort' in kwargs:
            target_port = kwargs['targetPort']
        if target_port is None:
            raise TypeError("Missing 'target_port' argument")

        _setter("health_check_port", health_check_port)
        _setter("ip", ip)
        _setter("protocol", protocol)
        _setter("source_port", source_port)
        _setter("target_port", target_port)

    @property
    @pulumi.getter(name="healthCheckPort")
    def health_check_port(self) -> int:
        return pulumi.get(self, "health_check_port")

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> int:
        return pulumi.get(self, "source_port")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> int:
        return pulumi.get(self, "target_port")


@pulumi.output_type
class GetRegionFilterResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter regions by this key. This may be one of `code`, `country`, `default`, `name`.
        :param Sequence[str] values: Only retrieves `regions` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        GetRegionFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            values=values,
            all=all,
            match_by=match_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             all: Optional[bool] = None,
             match_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")
        if match_by is None and 'matchBy' in kwargs:
            match_by = kwargs['matchBy']

        _setter("key", key)
        _setter("values", values)
        if all is not None:
            _setter("all", all)
        if match_by is not None:
            _setter("match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter regions by this key. This may be one of `code`, `country`, `default`, `name`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `regions` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetRegionRegionResult(dict):
    def __init__(__self__, *,
                 code: str,
                 country: str,
                 default: bool,
                 name: str):
        GetRegionRegionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            country=country,
            default=default,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             country: Optional[str] = None,
             default: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if code is None:
            raise TypeError("Missing 'code' argument")
        if country is None:
            raise TypeError("Missing 'country' argument")
        if default is None:
            raise TypeError("Missing 'default' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("code", code)
        _setter("country", country)
        _setter("default", default)
        _setter("name", name)

    @property
    @pulumi.getter
    def code(self) -> str:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def country(self) -> str:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def default(self) -> bool:
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRegionSortResult(dict):
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort regions by this key. This may be one of `code`, `country`, `default`, `name`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        GetRegionSortResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            direction=direction,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             direction: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("key", key)
        if direction is not None:
            _setter("direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort regions by this key. This may be one of `code`, `country`, `default`, `name`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetSizeFilterResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter sizes by this key. This may be one of `cpu`, `description`, `disk`, `gpu_type`, `gpu`, `name`, `ram`, `selectable`, `type`.
        :param Sequence[str] values: Only retrieves `sizes` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        GetSizeFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            values=values,
            all=all,
            match_by=match_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             all: Optional[bool] = None,
             match_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")
        if match_by is None and 'matchBy' in kwargs:
            match_by = kwargs['matchBy']

        _setter("key", key)
        _setter("values", values)
        if all is not None:
            _setter("all", all)
        if match_by is not None:
            _setter("match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter sizes by this key. This may be one of `cpu`, `description`, `disk`, `gpu_type`, `gpu`, `name`, `ram`, `selectable`, `type`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `sizes` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetSizeSizeResult(dict):
    def __init__(__self__, *,
                 cpu: int,
                 description: str,
                 disk: int,
                 gpu: int,
                 gpu_type: str,
                 name: str,
                 ram: int,
                 selectable: bool,
                 type: str):
        GetSizeSizeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu=cpu,
            description=description,
            disk=disk,
            gpu=gpu,
            gpu_type=gpu_type,
            name=name,
            ram=ram,
            selectable=selectable,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu: Optional[int] = None,
             description: Optional[str] = None,
             disk: Optional[int] = None,
             gpu: Optional[int] = None,
             gpu_type: Optional[str] = None,
             name: Optional[str] = None,
             ram: Optional[int] = None,
             selectable: Optional[bool] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu is None:
            raise TypeError("Missing 'cpu' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if disk is None:
            raise TypeError("Missing 'disk' argument")
        if gpu is None:
            raise TypeError("Missing 'gpu' argument")
        if gpu_type is None and 'gpuType' in kwargs:
            gpu_type = kwargs['gpuType']
        if gpu_type is None:
            raise TypeError("Missing 'gpu_type' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if ram is None:
            raise TypeError("Missing 'ram' argument")
        if selectable is None:
            raise TypeError("Missing 'selectable' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("cpu", cpu)
        _setter("description", description)
        _setter("disk", disk)
        _setter("gpu", gpu)
        _setter("gpu_type", gpu_type)
        _setter("name", name)
        _setter("ram", ram)
        _setter("selectable", selectable)
        _setter("type", type)

    @property
    @pulumi.getter
    def cpu(self) -> int:
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def disk(self) -> int:
        return pulumi.get(self, "disk")

    @property
    @pulumi.getter
    def gpu(self) -> int:
        return pulumi.get(self, "gpu")

    @property
    @pulumi.getter(name="gpuType")
    def gpu_type(self) -> str:
        return pulumi.get(self, "gpu_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ram(self) -> int:
        return pulumi.get(self, "ram")

    @property
    @pulumi.getter
    def selectable(self) -> bool:
        return pulumi.get(self, "selectable")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSizeSortResult(dict):
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort sizes by this key. This may be one of `cpu`, `description`, `disk`, `gpu_type`, `gpu`, `name`, `ram`, `selectable`, `type`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        GetSizeSortResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            direction=direction,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             direction: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("key", key)
        if direction is not None:
            _setter("direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort sizes by this key. This may be one of `cpu`, `description`, `disk`, `gpu_type`, `gpu`, `name`, `ram`, `selectable`, `type`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


