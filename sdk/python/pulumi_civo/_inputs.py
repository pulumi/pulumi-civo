# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'FirewallEgressRuleArgs',
    'FirewallEgressRuleArgsDict',
    'FirewallIngressRuleArgs',
    'FirewallIngressRuleArgsDict',
    'KubernetesClusterInstalledApplicationArgs',
    'KubernetesClusterInstalledApplicationArgsDict',
    'KubernetesClusterPoolsArgs',
    'KubernetesClusterPoolsArgsDict',
    'KubernetesClusterPoolsTaintArgs',
    'KubernetesClusterPoolsTaintArgsDict',
    'KubernetesNodePoolTaintArgs',
    'KubernetesNodePoolTaintArgsDict',
    'GetDatabaseVersionFilterArgs',
    'GetDatabaseVersionFilterArgsDict',
    'GetDatabaseVersionSortArgs',
    'GetDatabaseVersionSortArgsDict',
    'GetDiskImageFilterArgs',
    'GetDiskImageFilterArgsDict',
    'GetDiskImageSortArgs',
    'GetDiskImageSortArgsDict',
    'GetInstancesFilterArgs',
    'GetInstancesFilterArgsDict',
    'GetInstancesSortArgs',
    'GetInstancesSortArgsDict',
    'GetKubernetesVersionFilterArgs',
    'GetKubernetesVersionFilterArgsDict',
    'GetKubernetesVersionSortArgs',
    'GetKubernetesVersionSortArgsDict',
    'GetRegionFilterArgs',
    'GetRegionFilterArgsDict',
    'GetRegionSortArgs',
    'GetRegionSortArgsDict',
    'GetSizeFilterArgs',
    'GetSizeFilterArgsDict',
    'GetSizeSortArgs',
    'GetSizeSortArgsDict',
]

MYPY = False

if not MYPY:
    class FirewallEgressRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
        """
        cidrs: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (String) The ID of this resource.
        """
        label: NotRequired[pulumi.Input[str]]
        """
        A string that will be the displayed name/reference for this rule
        """
        port_range: NotRequired[pulumi.Input[str]]
        """
        The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
        """
elif False:
    FirewallEgressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallEgressRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 cidrs: pulumi.Input[Sequence[pulumi.Input[str]]],
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 port_range: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidrs: The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
        :param pulumi.Input[str] id: (String) The ID of this resource.
        :param pulumi.Input[str] label: A string that will be the displayed name/reference for this rule
        :param pulumi.Input[str] port_range: The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
        :param pulumi.Input[str] protocol: The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "cidrs", cidrs)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def cidrs(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
        """
        return pulumi.get(self, "cidrs")

    @cidrs.setter
    def cidrs(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "cidrs", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be the displayed name/reference for this rule
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class FirewallIngressRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
        """
        cidrs: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (String) The ID of this resource.
        """
        label: NotRequired[pulumi.Input[str]]
        """
        A string that will be the displayed name/reference for this rule
        """
        port_range: NotRequired[pulumi.Input[str]]
        """
        The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
        """
elif False:
    FirewallIngressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIngressRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 cidrs: pulumi.Input[Sequence[pulumi.Input[str]]],
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 port_range: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidrs: The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
        :param pulumi.Input[str] id: (String) The ID of this resource.
        :param pulumi.Input[str] label: A string that will be the displayed name/reference for this rule
        :param pulumi.Input[str] port_range: The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
        :param pulumi.Input[str] protocol: The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "cidrs", cidrs)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def cidrs(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
        """
        return pulumi.get(self, "cidrs")

    @cidrs.setter
    def cidrs(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "cidrs", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be the displayed name/reference for this rule
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class KubernetesClusterInstalledApplicationArgsDict(TypedDict):
        application: NotRequired[pulumi.Input[str]]
        """
        (String) name of the application
        """
        category: NotRequired[pulumi.Input[str]]
        """
        (String) category of the application
        """
        installed: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) whether application is installed or not
        """
        version: NotRequired[pulumi.Input[str]]
        """
        (String) version of the application
        """
elif False:
    KubernetesClusterInstalledApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterInstalledApplicationArgs:
    def __init__(__self__, *,
                 application: Optional[pulumi.Input[str]] = None,
                 category: Optional[pulumi.Input[str]] = None,
                 installed: Optional[pulumi.Input[bool]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] application: (String) name of the application
        :param pulumi.Input[str] category: (String) category of the application
        :param pulumi.Input[bool] installed: (Boolean) whether application is installed or not
        :param pulumi.Input[str] version: (String) version of the application
        """
        if application is not None:
            pulumi.set(__self__, "application", application)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if installed is not None:
            pulumi.set(__self__, "installed", installed)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def application(self) -> Optional[pulumi.Input[str]]:
        """
        (String) name of the application
        """
        return pulumi.get(self, "application")

    @application.setter
    def application(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        (String) category of the application
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def installed(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) whether application is installed or not
        """
        return pulumi.get(self, "installed")

    @installed.setter
    def installed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "installed", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        (String) version of the application
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class KubernetesClusterPoolsArgsDict(TypedDict):
        node_count: pulumi.Input[int]
        """
        Number of nodes in the nodepool
        """
        size: pulumi.Input[str]
        """
        Size of the nodes in the nodepool
        """
        instance_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Instance names in the nodepool
        """
        label: NotRequired[pulumi.Input[str]]
        """
        Node pool label, if you don't provide one, we will generate one for you
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        public_ip_node_pool: NotRequired[pulumi.Input[bool]]
        """
        Node pool belongs to the public ip node pool
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterPoolsTaintArgsDict']]]]
        """
        (see below for nested schema)

        Read-Only Output:
        """
elif False:
    KubernetesClusterPoolsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterPoolsArgs:
    def __init__(__self__, *,
                 node_count: pulumi.Input[int],
                 size: pulumi.Input[str],
                 instance_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 public_ip_node_pool: Optional[pulumi.Input[bool]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterPoolsTaintArgs']]]] = None):
        """
        :param pulumi.Input[int] node_count: Number of nodes in the nodepool
        :param pulumi.Input[str] size: Size of the nodes in the nodepool
        :param pulumi.Input[Sequence[pulumi.Input[str]]] instance_names: Instance names in the nodepool
        :param pulumi.Input[str] label: Node pool label, if you don't provide one, we will generate one for you
        :param pulumi.Input[bool] public_ip_node_pool: Node pool belongs to the public ip node pool
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterPoolsTaintArgs']]] taints: (see below for nested schema)
               
               Read-Only Output:
        """
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "size", size)
        if instance_names is not None:
            pulumi.set(__self__, "instance_names", instance_names)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if public_ip_node_pool is not None:
            pulumi.set(__self__, "public_ip_node_pool", public_ip_node_pool)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> pulumi.Input[int]:
        """
        Number of nodes in the nodepool
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[str]:
        """
        Size of the nodes in the nodepool
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="instanceNames")
    def instance_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Instance names in the nodepool
        """
        return pulumi.get(self, "instance_names")

    @instance_names.setter
    def instance_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "instance_names", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Node pool label, if you don't provide one, we will generate one for you
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="publicIpNodePool")
    def public_ip_node_pool(self) -> Optional[pulumi.Input[bool]]:
        """
        Node pool belongs to the public ip node pool
        """
        return pulumi.get(self, "public_ip_node_pool")

    @public_ip_node_pool.setter
    def public_ip_node_pool(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_ip_node_pool", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterPoolsTaintArgs']]]]:
        """
        (see below for nested schema)

        Read-Only Output:
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterPoolsTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class KubernetesClusterPoolsTaintArgsDict(TypedDict):
        effect: pulumi.Input[str]
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    KubernetesClusterPoolsTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterPoolsTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class KubernetesNodePoolTaintArgsDict(TypedDict):
        effect: pulumi.Input[str]
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    KubernetesNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetDatabaseVersionFilterArgsDict(TypedDict):
        key: str
        """
        Filter versions by this key. This may be one of `default`, `engine`, `version`.
        """
        values: Sequence[str]
        """
        Only retrieves `versions` which keys has value that matches one of the values provided here
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
elif False:
    GetDatabaseVersionFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDatabaseVersionFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter versions by this key. This may be one of `default`, `engine`, `version`.
        :param Sequence[str] values: Only retrieves `versions` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter versions by this key. This may be one of `default`, `engine`, `version`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `versions` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetDatabaseVersionSortArgsDict(TypedDict):
        key: str
        """
        Sort versions by this key. This may be one of `default`, `engine`, `version`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetDatabaseVersionSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDatabaseVersionSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort versions by this key. This may be one of `default`, `engine`, `version`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort versions by this key. This may be one of `default`, `engine`, `version`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetDiskImageFilterArgsDict(TypedDict):
        key: str
        """
        Filter diskimages by this key. This may be one of `id`, `label`, `name`, `version`.
        """
        values: Sequence[str]
        """
        Only retrieves `diskimages` which keys has value that matches one of the values provided here
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
elif False:
    GetDiskImageFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDiskImageFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter diskimages by this key. This may be one of `id`, `label`, `name`, `version`.
        :param Sequence[str] values: Only retrieves `diskimages` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter diskimages by this key. This may be one of `id`, `label`, `name`, `version`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `diskimages` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetDiskImageSortArgsDict(TypedDict):
        key: str
        """
        Sort diskimages by this key. This may be one of `id`, `label`, `name`, `version`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetDiskImageSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDiskImageSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort diskimages by this key. This may be one of `id`, `label`, `name`, `version`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort diskimages by this key. This may be one of `id`, `label`, `name`, `version`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetInstancesFilterArgsDict(TypedDict):
        key: str
        """
        Filter instances by this key. This may be one of `cpu_cores`, `created_at`, `disk_gb`, `firewall_id`, `hostname`, `id`, `initial_password`, `initial_user`, `network_id`, `notes`, `private_ip`, `pseudo_ip`, `public_ip`, `ram_mb`, `region`, `reverse_dns`, `script`, `size`, `sshkey_id`, `status`, `tags`, `template`.
        """
        values: Sequence[str]
        """
        Only retrieves `instances` which keys has value that matches one of the values provided here
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
elif False:
    GetInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancesFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter instances by this key. This may be one of `cpu_cores`, `created_at`, `disk_gb`, `firewall_id`, `hostname`, `id`, `initial_password`, `initial_user`, `network_id`, `notes`, `private_ip`, `pseudo_ip`, `public_ip`, `ram_mb`, `region`, `reverse_dns`, `script`, `size`, `sshkey_id`, `status`, `tags`, `template`.
        :param Sequence[str] values: Only retrieves `instances` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter instances by this key. This may be one of `cpu_cores`, `created_at`, `disk_gb`, `firewall_id`, `hostname`, `id`, `initial_password`, `initial_user`, `network_id`, `notes`, `private_ip`, `pseudo_ip`, `public_ip`, `ram_mb`, `region`, `reverse_dns`, `script`, `size`, `sshkey_id`, `status`, `tags`, `template`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `instances` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetInstancesSortArgsDict(TypedDict):
        key: str
        """
        Sort instances by this key. This may be one of `cpu_cores`, `created_at`, `disk_gb`, `firewall_id`, `hostname`, `id`, `initial_password`, `initial_user`, `network_id`, `notes`, `private_ip`, `pseudo_ip`, `public_ip`, `ram_mb`, `region`, `reverse_dns`, `script`, `size`, `sshkey_id`, `status`, `template`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetInstancesSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancesSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort instances by this key. This may be one of `cpu_cores`, `created_at`, `disk_gb`, `firewall_id`, `hostname`, `id`, `initial_password`, `initial_user`, `network_id`, `notes`, `private_ip`, `pseudo_ip`, `public_ip`, `ram_mb`, `region`, `reverse_dns`, `script`, `size`, `sshkey_id`, `status`, `template`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort instances by this key. This may be one of `cpu_cores`, `created_at`, `disk_gb`, `firewall_id`, `hostname`, `id`, `initial_password`, `initial_user`, `network_id`, `notes`, `private_ip`, `pseudo_ip`, `public_ip`, `ram_mb`, `region`, `reverse_dns`, `script`, `size`, `sshkey_id`, `status`, `template`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetKubernetesVersionFilterArgsDict(TypedDict):
        key: str
        """
        Filter versions by this key. This may be one of `default`, `label`, `type`, `version`.
        """
        values: Sequence[str]
        """
        Only retrieves `versions` which keys has value that matches one of the values provided here
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
elif False:
    GetKubernetesVersionFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubernetesVersionFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter versions by this key. This may be one of `default`, `label`, `type`, `version`.
        :param Sequence[str] values: Only retrieves `versions` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter versions by this key. This may be one of `default`, `label`, `type`, `version`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `versions` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetKubernetesVersionSortArgsDict(TypedDict):
        key: str
        """
        Sort versions by this key. This may be one of `default`, `label`, `type`, `version`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetKubernetesVersionSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubernetesVersionSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort versions by this key. This may be one of `default`, `label`, `type`, `version`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort versions by this key. This may be one of `default`, `label`, `type`, `version`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetRegionFilterArgsDict(TypedDict):
        key: str
        """
        Filter regions by this key. This may be one of `code`, `country`, `default`, `name`.
        """
        values: Sequence[str]
        """
        Only retrieves `regions` which keys has value that matches one of the values provided here
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
elif False:
    GetRegionFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRegionFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter regions by this key. This may be one of `code`, `country`, `default`, `name`.
        :param Sequence[str] values: Only retrieves `regions` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter regions by this key. This may be one of `code`, `country`, `default`, `name`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `regions` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetRegionSortArgsDict(TypedDict):
        key: str
        """
        Sort regions by this key. This may be one of `code`, `country`, `default`, `name`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetRegionSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRegionSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort regions by this key. This may be one of `code`, `country`, `default`, `name`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort regions by this key. This may be one of `code`, `country`, `default`, `name`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetSizeFilterArgsDict(TypedDict):
        key: str
        """
        Filter sizes by this key. This may be one of `cpu`, `description`, `disk`, `gpu_type`, `gpu`, `name`, `ram`, `selectable`, `type`.
        """
        values: Sequence[str]
        """
        Only retrieves `sizes` which keys has value that matches one of the values provided here
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
elif False:
    GetSizeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSizeFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter sizes by this key. This may be one of `cpu`, `description`, `disk`, `gpu_type`, `gpu`, `name`, `ram`, `selectable`, `type`.
        :param Sequence[str] values: Only retrieves `sizes` which keys has value that matches one of the values provided here
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter sizes by this key. This may be one of `cpu`, `description`, `disk`, `gpu_type`, `gpu`, `name`, `ram`, `selectable`, `type`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves `sizes` which keys has value that matches one of the values provided here
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetSizeSortArgsDict(TypedDict):
        key: str
        """
        Sort sizes by this key. This may be one of `cpu`, `description`, `disk`, `gpu_type`, `gpu`, `name`, `ram`, `selectable`, `type`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetSizeSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSizeSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort sizes by this key. This may be one of `cpu`, `description`, `disk`, `gpu_type`, `gpu`, `name`, `ram`, `selectable`, `type`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort sizes by this key. This may be one of `cpu`, `description`, `disk`, `gpu_type`, `gpu`, `name`, `ram`, `selectable`, `type`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


