// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * Provides a Civo firewall rule resource. This can be used to create, modify, and delete firewalls rules. This resource don't have an update option because Civo backend doesn't support it at this moment. In that case, we use `ForceNew` for all object in the resource.
 *
 * ## Import
 *
 * # using firewall_id:firewall_rule_id
 *
 * ```sh
 *  $ pulumi import civo:index/firewallRule:FirewallRule http b8ecd2ab-2267-4a5e-8692-cbf1d32583e3:4b0022ee-00b2-4f81-a40d-b4f8728923a7
 * ```
 */
export class FirewallRule extends pulumi.CustomResource {
    /**
     * Get an existing FirewallRule resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: FirewallRuleState, opts?: pulumi.CustomResourceOptions): FirewallRule {
        return new FirewallRule(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'civo:index/firewallRule:FirewallRule';

    /**
     * Returns true if the given object is an instance of FirewallRule.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is FirewallRule {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === FirewallRule.__pulumiType;
    }

    /**
     * The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
     */
    public readonly action!: pulumi.Output<string>;
    /**
     * The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
     */
    public readonly cidrs!: pulumi.Output<string[]>;
    /**
     * The direction of the rule can be ingress or egress
     */
    public readonly direction!: pulumi.Output<string>;
    /**
     * The end of the port range (this is optional, by default it will only apply to the single port listed in start_port)
     */
    public readonly endPort!: pulumi.Output<string>;
    /**
     * The Firewall ID
     */
    public readonly firewallId!: pulumi.Output<string>;
    /**
     * A string that will be the displayed name/reference for this rule
     */
    public readonly label!: pulumi.Output<string>;
    /**
     * The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
     */
    public readonly protocol!: pulumi.Output<string>;
    /**
     * The region for this rule
     */
    public readonly region!: pulumi.Output<string>;
    /**
     * The start of the port range to configure for this rule (or the single port if required)
     */
    public readonly startPort!: pulumi.Output<string>;

    /**
     * Create a FirewallRule resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: FirewallRuleArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: FirewallRuleArgs | FirewallRuleState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as FirewallRuleState | undefined;
            resourceInputs["action"] = state ? state.action : undefined;
            resourceInputs["cidrs"] = state ? state.cidrs : undefined;
            resourceInputs["direction"] = state ? state.direction : undefined;
            resourceInputs["endPort"] = state ? state.endPort : undefined;
            resourceInputs["firewallId"] = state ? state.firewallId : undefined;
            resourceInputs["label"] = state ? state.label : undefined;
            resourceInputs["protocol"] = state ? state.protocol : undefined;
            resourceInputs["region"] = state ? state.region : undefined;
            resourceInputs["startPort"] = state ? state.startPort : undefined;
        } else {
            const args = argsOrState as FirewallRuleArgs | undefined;
            if ((!args || args.action === undefined) && !opts.urn) {
                throw new Error("Missing required property 'action'");
            }
            if ((!args || args.cidrs === undefined) && !opts.urn) {
                throw new Error("Missing required property 'cidrs'");
            }
            if ((!args || args.direction === undefined) && !opts.urn) {
                throw new Error("Missing required property 'direction'");
            }
            if ((!args || args.firewallId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'firewallId'");
            }
            resourceInputs["action"] = args ? args.action : undefined;
            resourceInputs["cidrs"] = args ? args.cidrs : undefined;
            resourceInputs["direction"] = args ? args.direction : undefined;
            resourceInputs["endPort"] = args ? args.endPort : undefined;
            resourceInputs["firewallId"] = args ? args.firewallId : undefined;
            resourceInputs["label"] = args ? args.label : undefined;
            resourceInputs["protocol"] = args ? args.protocol : undefined;
            resourceInputs["region"] = args ? args.region : undefined;
            resourceInputs["startPort"] = args ? args.startPort : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(FirewallRule.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering FirewallRule resources.
 */
export interface FirewallRuleState {
    /**
     * The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
     */
    action?: pulumi.Input<string>;
    /**
     * The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
     */
    cidrs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The direction of the rule can be ingress or egress
     */
    direction?: pulumi.Input<string>;
    /**
     * The end of the port range (this is optional, by default it will only apply to the single port listed in start_port)
     */
    endPort?: pulumi.Input<string>;
    /**
     * The Firewall ID
     */
    firewallId?: pulumi.Input<string>;
    /**
     * A string that will be the displayed name/reference for this rule
     */
    label?: pulumi.Input<string>;
    /**
     * The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
     */
    protocol?: pulumi.Input<string>;
    /**
     * The region for this rule
     */
    region?: pulumi.Input<string>;
    /**
     * The start of the port range to configure for this rule (or the single port if required)
     */
    startPort?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a FirewallRule resource.
 */
export interface FirewallRuleArgs {
    /**
     * The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
     */
    action: pulumi.Input<string>;
    /**
     * The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
     */
    cidrs: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The direction of the rule can be ingress or egress
     */
    direction: pulumi.Input<string>;
    /**
     * The end of the port range (this is optional, by default it will only apply to the single port listed in start_port)
     */
    endPort?: pulumi.Input<string>;
    /**
     * The Firewall ID
     */
    firewallId: pulumi.Input<string>;
    /**
     * A string that will be the displayed name/reference for this rule
     */
    label?: pulumi.Input<string>;
    /**
     * The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
     */
    protocol?: pulumi.Input<string>;
    /**
     * The region for this rule
     */
    region?: pulumi.Input<string>;
    /**
     * The start of the port range to configure for this rule (or the single port if required)
     */
    startPort?: pulumi.Input<string>;
}
